from types import Constraint, Solution

class ValueConstraint(Constraint):
    """
    A concrete constraint generated by the Parser.
    Represents a direct link found in text, e.g., 'The Englishman lives in the red house'.
    """
    def __init__(self, subject: str, value: str):
        self.subject = subject
        self.value = value

    def isSatisfied(self, solution: Solution) -> bool:
        # Logic to be implemented by Solver team
        return True
    
    def __repr__(self):
        return f"Constraint: [{self.subject}] <--> [{self.value}]"

class ImplicationConstraint(Constraint):
    def __init__(self, if_key: str, if_value: str, then_key: str, then_value: str):
        self.if_key = if_key
        self.if_value = if_value
        self.then_key = then_key
        self.then_value = then_value

    def isSatisfied(self, solution: Solution) -> bool:
        for person in solution.var:
            props = person["properties"]
            if props.get(self.if_key) == self.if_value:
                if props.get(self.then_key) != self.then_value:
                    return False
        return True


class LeftRightConstraint(Constraint):
    def __init__(self, key1: str, value1: str, key2: str, value2: str, direction: str):
        self.key1 = key1
        self.value1 = value1
        self.key2 = key2
        self.value2 = value2
        self.direction = direction  # "left" or "right"

    def isSatisfied(self, solution: Solution) -> bool:
        index1 = None
        index2 = None

        for i, person in enumerate(solution.var):
            props = person["properties"]
            if props.get(self.key1) == self.value1:
                index1 = i
            if props.get(self.key2) == self.value2:
                index2 = i

        if index1 is None or index2 is None:
            return True

        if self.direction == "left":
            return index1 == index2 - 1
        else:
            return index1 == index2 + 1


class UniqueConstraint(Constraint):
    """
    Ensures that a specific property value appears exactly once across all persons.
    """
    def __init__(self, property_name: str, value: str):
        self.property_name = property_name
        self.value = value

    def isSatisfied(self, solution: Solution) -> bool:
        # Logic to be implemented by Solver team
        return True
    
    def __repr__(self):
        return f"UniqueConstraint: [{self.property_name}]=[{self.value}] must be unique"

class NeighborConstraint(Constraint):
    """
    Ensures that two persons with specific properties are neighbors (adjacent positions).
    """
    def __init__(self, subject: str, neighbor: str):
        self.subject = subject
        self.neighbor = neighbor

    def isSatisfied(self, solution: Solution) -> bool:
        # Logic to be implemented by Solver team
        return True
    
    def __repr__(self):
        return f"NeighborConstraint: [{self.subject}] next to [{self.neighbor}]"

class IsNotConstraint(Constraint):
    """
    Ensures that a subject does not have a specific value.
    """
    def __init__(self, subject: str, value: str):
        self.subject = subject
        self.value = value

    def isSatisfied(self, solution: Solution) -> bool:
        # Logic to be implemented by Solver team
        return True
    
    def __repr__(self):
        return f"IsNotConstraint: [{self.subject}] is NOT [{self.value}]"