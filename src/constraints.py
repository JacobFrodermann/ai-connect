from classes import Constraint, Solution

class ValueConstraint(Constraint):
    """
    A concrete constraint generated by the Parser.
    Represents a direct link found in text, e.g., 'The Englishman lives in the red house'.
    """
    def __init__(self, subject: str, value: str):
        self.subject = subject
        self.value = value

    def isSatisfied(self, solution: Solution) -> bool:
        subject_index = None
        value_index = None

        for i, person in enumerate(solution.var):
            props = person.get("properties", {})

            if self.subject in props.values():
                subject_index = i
            if self.value in props.values():
                value_index = i

        # If one or both not assigned yet → cannot be violated
        if subject_index is None or value_index is None:
            return True

        # They must refer to the same person
        return subject_index == value_index
    
    def __repr__(self):
        return f"Constraint: [{self.subject}] <--> [{self.value}]"


class ImplicationConstraint(Constraint):
    def __init__(self, if_key: str, if_value: str, then_key: str, then_value: str):
        self.if_key = if_key
        self.if_value = if_value
        self.then_key = then_key
        self.then_value = then_value

    def isSatisfied(self, solution: Solution) -> bool:
        for person in solution.ppl:
            props = person["properties"]
            if props.get(self.if_key) == self.if_value:
                if props.get(self.then_key) != self.then_value:
                    return False
        return True


class LeftRightConstraint(Constraint):
    def __init__(self, key1: str, value1: str, key2: str, value2: str, direction: str):
        self.key1 = key1
        self.value1 = value1
        self.key2 = key2
        self.value2 = value2
        self.direction = direction  # "left" or "right"

    def isSatisfied(self, solution: Solution) -> bool:
        index1 = None
        index2 = None

        for i, person in enumerate(solution.ppl):
            props = person["properties"]
            if props.get(self.key1) == self.value1:
                index1 = i
            if props.get(self.key2) == self.value2:
                index2 = i

        if index1 is None or index2 is None:
            return True

        if self.direction == "left":
            return index1 == index2 - 1
        else:
            return index1 == index2 + 1


class UniqueConstraint(Constraint):
    """
    Ensures that a specific property value appears exactly once across all persons.
    """
    def __init__(self, property_name: str, value: str):
        self.property_name = property_name
        self.value = value

    def isSatisfied(self, solution: Solution) -> bool:
        count = 0

        for person in solution.var:
            props = person.get("properties", {})
            if props.get(self.property_name) == self.value:
                count += 1
                if count > 1:
                    return False

        return True

class NeighborConstraint(Constraint):
    """
    Ensures that two persons with specific properties are neighbors (adjacent positions).
    """
    def __init__(self, subject: str, neighbor: str):
        self.subject = subject
        self.neighbor = neighbor

    def isSatisfied(self, solution: Solution) -> bool:
        index_subject = None
        index_neighbor = None

        for i, person in enumerate(solution.var):
            props = person.get("properties", {})

            if self.subject in props.values():
                index_subject = i
            if self.neighbor in props.values():
                index_neighbor = i

        # Not fully assigned yet → cannot be violated
        if index_subject is None or index_neighbor is None:
            return True

        return abs(index_subject - index_neighbor) == 1


class IsNotConstraint(Constraint):
    """
    Ensures that a subject does not have a specific value.
    """
    def __init__(self, subject: str, value: str):
        self.subject = subject
        self.value = value

    def isSatisfied(self, solution: Solution) -> bool:
        for person in solution.var:
            props = person.get("properties", {})

            if self.subject in props.values():
                if self.value in props.values():
                    return False

        return True
    
class BetweenConstraint(Constraint):
    pass


class OrConstraint(Constraint):
    """
    Ensures that at least one of two conditions holds.
    """
    def __init__(self, option1: str, option2: str):
        self.option1 = option1
        self.option2 = option2

    def isSatisfied(self, solution: Solution) -> bool:
        option1_found = False
        option2_found = False

        for person in solution.var:
            props = person.get("properties", {})

            if self.option1 in props.values():
                option1_found = True
            if self.option2 in props.values():
                option2_found = True

        # If at least one option is present → satisfied
        if option1_found or option2_found:
            return True

        # Neither assigned yet → cannot be violated
        return True

    def __repr__(self):
        return f"OrConstraint: [{self.option1}] OR [{self.option2}]"


