import pandas as pd
from textblob import TextBlob
from typing import List, TypedDict, Set

# --- Core Data Structures (Updated for Parser needs) ---

class Person(TypedDict):
    properties: dict[str, str]

class Solution:
    var: List[Person] = []

class Constraint:
    """
    Base interface for all logical rules.
    """
    def isSatisfied(self, solution: Solution) -> bool:
        return True

class ValueConstraint(Constraint):
    """
    A concrete constraint generated by the Parser.
    Represents a direct link found in text, e.g., 'The Englishman lives in the red house'.
    """
    def __init__(self, subject: str, value: str):
        self.subject = subject
        self.value = value

    def isSatisfied(self, solution: Solution) -> bool:
        # Logic to be implemented by Solver team
        return True
    
    def __repr__(self):
        return f"Constraint: [{self.subject}] <--> [{self.value}]"

class ImplicationConstraint(Constraint):
    def __init__(self, if_key: str, if_value: str, then_key: str, then_value: str):
        self.if_key = if_key
        self.if_value = if_value
        self.then_key = then_key
        self.then_value = then_value

    def isSatisfied(self, solution: Solution) -> bool:
        for person in solution.var:
            props = person["properties"]
            if props.get(self.if_key) == self.if_value:
                if props.get(self.then_key) != self.then_value:
                    return False
        return True


class LeftRightConstraint(Constraint):
    def __init__(self, key1: str, value1: str, key2: str, value2: str, direction: str):
        self.key1 = key1
        self.value1 = value1
        self.key2 = key2
        self.value2 = value2
        self.direction = direction  # "left" or "right"

    def isSatisfied(self, solution: Solution) -> bool:
        index1 = None
        index2 = None

        for i, person in enumerate(solution.var):
            props = person["properties"]
            if props.get(self.key1) == self.value1:
                index1 = i
            if props.get(self.key2) == self.value2:
                index2 = i

        if index1 is None or index2 is None:
            return True

        if self.direction == "left":
            return index1 == index2 - 1
        else:
            return index1 == index2 + 1


class UniqueConstraint(Constraint):
    """
    Ensures that a specific property value appears exactly once across all persons.
    """
    def __init__(self, property_name: str, value: str):
        self.property_name = property_name
        self.value = value

    def isSatisfied(self, solution: Solution) -> bool:
        # Logic to be implemented by Solver team
        return True
    
    def __repr__(self):
        return f"UniqueConstraint: [{self.property_name}]=[{self.value}] must be unique"

class NeighborConstraint(Constraint):
    """
    Ensures that two persons with specific properties are neighbors (adjacent positions).
    """
    def __init__(self, subject: str, neighbor: str):
        self.subject = subject
        self.neighbor = neighbor

    def isSatisfied(self, solution: Solution) -> bool:
        # Logic to be implemented by Solver team
        return True
    
    def __repr__(self):
        return f"NeighborConstraint: [{self.subject}] next to [{self.neighbor}]"

class IsNotConstraint(Constraint):
    """
    Ensures that a subject does not have a specific value.
    """
    def __init__(self, subject: str, value: str):
        self.subject = subject
        self.value = value

    def isSatisfied(self, solution: Solution) -> bool:
        # Logic to be implemented by Solver team
        return True
    
    def __repr__(self):
        return f"IsNotConstraint: [{self.subject}] is NOT [{self.value}]"


class RawProblem:
    """
    Holds the raw data ingested from the dataset.
    Updated to include 'text' which comes from the 'puzzle' column in ZebraLogicBench.
    """
    ID: str
    text: str

    """
    Gridmode specific
    """
    size: str
    
    """"
    Multiple Choice Mode specific
    """
    question: str
    choiches: str

    def __init__(self, id: str, text: str, size: str):
        self.ID = id
        self.text = text
        self.size = size

class ParsedProblem:
    """
    The structured output produced by the Parser.
    Updated to store the extracted constraints and entities.
    """
    ID: str
    constraints: List[Constraint]
    entities: Set[str] # Valid entities found (e.g., 'Englishman', 'Red', 'Dog')
    
    """
    Gridmode specific
    """
    size: tuple[int, int]

    """"
    Multiple Choice Mode specific
    """
    question: List[str]
    choiches: List[str]

    def __init__(self, id: str, width: int, height: int):
        self.ID = id
        self.constraints = []
        self.entities = set()
        self.size = (width, height)

# --- THE PARSER (Your Part) ---

class Parser:
    """
    Responsible for converting raw natural language text into structured Constraints
    using an NLP pipeline (Pandas + TextBlob).
    """
        
    def parse(self, raw: RawProblem) -> ParsedProblem:
        parsed = ParsedProblem(raw.ID)
        
        # 1. Ingestion: Load text into DataFrame for vectorized processing
        # We split by '.' to analyze the puzzle sentence-by-sentence.
        sentences = raw.text.split('.')
        df = pd.DataFrame(sentences, columns=["raw_text"])
        
        # Filter out empty rows caused by splitting
        df = df[df["raw_text"].str.strip() != ""]
        
        # 2. Preprocessing Pipeline
        # Convert to lowercase to standardize (e.g., "Red" -> "red")
        df["processed"] = df["raw_text"].apply(lambda x: " ".join(x.lower().split()))
        
        # Clean punctuation but preserve sentence structure
        # regex=True ensures we remove special chars like '!', ',' but keep spaces
        df["processed"] = df["processed"].str.replace(r"[^\w\s]", "", regex=True)
        
        # Note: We intentionally skip Stopword Removal.
        # Logic keywords like "not", "next to", "same" are crucial for puzzles.

        # 3. Feature Extraction (POS Tagging)
        # We use TextBlob to identify parts of speech:
        # NN (Noun), JJ (Adjective), VB (Verb)
        try:
            df["tags"] = df["processed"].apply(lambda x: TextBlob(x).tags)
        except Exception as e:
            print(f"NLP Error: {e}. Ensure TextBlob corpora is downloaded.")
            return parsed

        # 4. Logic Extraction Loop
        # Iterate through processed sentences to generate Constraints
        for index, row in df.iterrows():
            self._extract_constraints(row["tags"], parsed)
            
        return parsed

    def _extract_constraints(self, tags: List[tuple], parsed_obj: ParsedProblem):
        """
        Analyzes POS tags to extract logical relationships.
        """
        # Extract potential entities (Nouns) and properties (Adjectives/Nouns)
        # NN* captures NN, NNS, NNP, NNPS
        nouns = [word for word, tag in tags if tag.startswith('NN')]
        adjectives = [word for word, tag in tags if tag.startswith('JJ')]
        
        # Heuristic 1: Attribution (Subject + Adjective)
        # Example: "The Englishman(NN) lives in the Red(JJ) house."
        if len(nouns) >= 1 and len(adjectives) >= 1:
            subject = nouns[0]
            value = adjectives[0]
            self._add_constraint(parsed_obj, subject, value)

        # Heuristic 2: Direct Association (Noun + Noun)
        # Example: "The Spaniard(NN) owns the Dog(NN)."
        elif len(nouns) >= 2:
            subject = nouns[0]
            value = nouns[1]
            # Avoid self-referencing (e.g., "The house is a house")
            if subject != value:
                self._add_constraint(parsed_obj, subject, value)

        # -------------------------------
    # NEW: LEFT / RIGHT CONSTRAINT
    # -------------------------------
    words = [w for w, _ in tags]

    if "left" in words or "right" in words:
        direction = "left" if "left" in words else "right"
        nouns_lr = [w for w, t in tags if t.startswith("NN")]

        if len(nouns_lr) >= 2:
            parsed_obj.constraints.append(
                LeftRightConstraint(
                    key1="color",
                    value1=nouns_lr[0],
                    key2="color",
                    value2=nouns_lr[1],
                    direction=direction
                )
            )

    # -------------------------------
    # NEW: IMPLICATION CONSTRAINT
    # -------------------------------
    if "if" in words and "then" in words:
        nouns_impl = [w for w, t in tags if t.startswith("NN")]

        if len(nouns_impl) >= 4:
            parsed_obj.constraints.append(
                ImplicationConstraint(
                    if_key="attr1",
                    if_value=nouns_impl[0],
                    then_key="attr2",
                    then_value=nouns_impl[1]
                )
            )


    def _add_constraint(self, parsed_obj: ParsedProblem, entity1: str, entity2: str):
        """
        Helper to add a constraint and register entities.
        """
        parsed_obj.entities.add(entity1)
        parsed_obj.entities.add(entity2)
        parsed_obj.constraints.append(ValueConstraint(entity1, entity2))
    
    def parseGridmode(self, raw: RawProblem) -> ParsedProblem:
        parsed = self.parse(raw)

        sp = raw.size.split('*')
        parsed.size = (int(sp[0]), int(sp[1]))
        
        return parsed
        
    def parseMultipleChoice(self, raw: RawProblem) -> ParsedProblem:
        parsed = self.parse(raw)

        # TODO
         
        return parsed

class Solver:
    """
    Complete symbolic CSP solver for ZebraLogicBench-style puzzles.
    Uses backtracking + constraint checking + uniqueness enforcement.
    """

    def __init__(self):
        self.steps = 0  # required for efficiency score

    def solve(self, problem: ParsedProblem) -> Solution:
        self.steps = 0

        width, height = problem.size
        n = width  # number of houses

        # -------------------------------
        # 1. Initialize empty houses
        # -------------------------------
        solution = Solution()
        solution.var = [{"properties": {}} for _ in range(n)]

        # -------------------------------
        # 2. Prepare entities (values)
        # -------------------------------
        entities = list(problem.entities)

        # Each entity can be assigned to exactly one house
        domains = {entity: set(range(n)) for entity in entities}

        # -------------------------------
        # 3. Backtracking search
        # -------------------------------
        success = self._backtrack(
            solution,
            entities,
            domains,
            problem.constraints,
            assigned_entities=set()
        )

        return solution if success else Solution()

    # =====================================================
    # BACKTRACKING
    # =====================================================
    def _backtrack(self, solution, entities, domains, constraints, assigned_entities):
        # All entities assigned â†’ final check
        if len(assigned_entities) == len(entities):
            return self._check_constraints(solution, constraints)

        self.steps += 1

        # Choose next unassigned entity
        entity = next(e for e in entities if e not in assigned_entities)

        for house_idx in domains[entity]:
            # Enforce uniqueness (no duplicate entity in same house)
            if entity in solution.var[house_idx]["properties"].values():
                continue

            # Assign
            solution.var[house_idx]["properties"][entity] = entity
            assigned_entities.add(entity)

            # Constraint check (early pruning)
            if self._check_constraints(solution, constraints):
                if self._backtrack(solution, entities, domains, constraints, assigned_entities):
                    return True

            # Undo assignment
            del solution.var[house_idx]["properties"][entity]
            assigned_entities.remove(entity)

        return False

    # =====================================================
    # CONSTRAINT CHECKING
    # =====================================================
    def _check_constraints(self, solution, constraints):
        # Enforce all constraints
        for constraint in constraints:
            if not constraint.isSatisfied(solution):
                return False

        # Enforce ALL-DIFFERENT (global uniqueness)
        seen = set()
        for house in solution.var:
            for value in house["properties"].values():
                if value in seen:
                    return False
                seen.add(value)

        return True


# --- verification (Not part of the class file, but for testing) ---
if __name__ == "__main__":
    # Simulating data from the ZebraLogicBench 'puzzle' column
    sample_puzzle_text = "There are 5 houses. The Englishman lives in the red house. The Spaniard owns the dog."
    
    raw = RawProblem("lgp-test-5x6-16", sample_puzzle_text)
    parser = Parser()
    result = parser.parse(raw)
    
    print(f"Parsed ID: {result.ID}")
    print(f"Entities: {result.entities}")
    print(f"Constraints: {result.constraints}")
