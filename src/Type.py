import pandas as pd
from textblob import TextBlob
from typing import List, TypedDict, Set

# --- Core Data Structures (Updated for Parser needs) ---

class Person(TypedDict):
    properties: dict[str, str]


class Constraint:
    """
    Base interface for all logical rules.
    """
    def isSatisfied(self, solution: Solution) -> bool:
        return True

class ValueConstraint(Constraint):
    """
    A concrete constraint generated by the Parser.
    Represents a direct link found in text, e.g., 'The Englishman lives in the red house'.
    """
    def __init__(self, subject: str, value: str):
        self.subject = subject
        self.value = value

    def isSatisfied(self, solution: Solution) -> bool:
        # Logic to be implemented by Solver team
        return True
    
    def __repr__(self):
        return f"Constraint: [{self.subject}] <--> [{self.value}]"

class ImplicationConstraint(Constraint):
    def __init__(self, if_key: str, if_value: str, then_key: str, then_value: str):
        self.if_key = if_key
        self.if_value = if_value
        self.then_key = then_key
        self.then_value = then_value

    def isSatisfied(self, solution: Solution) -> bool:
        for person in solution.var:
            props = person["properties"]
            if props.get(self.if_key) == self.if_value:
                if props.get(self.then_key) != self.then_value:
                    return False
        return True


class LeftRightConstraint(Constraint):
    def __init__(self, key1: str, value1: str, key2: str, value2: str, direction: str):
        self.key1 = key1
        self.value1 = value1
        self.key2 = key2
        self.value2 = value2
        self.direction = direction  # "left" or "right"

    def isSatisfied(self, solution: Solution) -> bool:
        index1 = None
        index2 = None

        for i, person in enumerate(solution.var):
            props = person["properties"]
            if props.get(self.key1) == self.value1:
                index1 = i
            if props.get(self.key2) == self.value2:
                index2 = i

        if index1 is None or index2 is None:
            return True

        if self.direction == "left":
            return index1 == index2 - 1
        else:
            return index1 == index2 + 1


class UniqueConstraint(Constraint):
    """
    Ensures that a specific property value appears exactly once across all persons.
    """
    def __init__(self, property_name: str, value: str):
        self.property_name = property_name
        self.value = value

    def isSatisfied(self, solution: Solution) -> bool:
        # Logic to be implemented by Solver team
        return True
    
    def __repr__(self):
        return f"UniqueConstraint: [{self.property_name}]=[{self.value}] must be unique"

class NeighborConstraint(Constraint):
    """
    Ensures that two persons with specific properties are neighbors (adjacent positions).
    """
    def __init__(self, subject: str, neighbor: str):
        self.subject = subject
        self.neighbor = neighbor

    def isSatisfied(self, solution: Solution) -> bool:
        # Logic to be implemented by Solver team
        return True
    
    def __repr__(self):
        return f"NeighborConstraint: [{self.subject}] next to [{self.neighbor}]"

class IsNotConstraint(Constraint):
    """
    Ensures that a subject does not have a specific value.
    """
    def __init__(self, subject: str, value: str):
        self.subject = subject
        self.value = value

    def isSatisfied(self, solution: Solution) -> bool:
        # Logic to be implemented by Solver team
        return True
    
    def __repr__(self):
        return f"IsNotConstraint: [{self.subject}] is NOT [{self.value}]"


class RawProblem:
    """
    Holds the raw data ingested from the dataset.
    Updated to include 'text' which comes from the 'puzzle' column in ZebraLogicBench.
    """
    ID: str
    text: str

    """
    Gridmode specific
    """
    size: str
    
    """"
    Multiple Choice Mode specific
    """
    question: str
    choiches: str

    def __init__(self, id: str, text: str, size: str, question: str, choiches: str):
        self.ID = id
        self.text = text
        self.size = size

class ParsedProblem:
    """
    The structured output produced by the Parser.
    Updated to store the extracted constraints and entities.
    """
    ID: str
    constraints: List[Constraint]
    entities: Set[str] # Valid entities found (e.g., 'Englishman', 'Red', 'Dog')
    
    """
    Gridmode specific
    """
    size: tuple[int, int]

    """"
    Multiple Choice Mode specific
    """
    requestedProperty: str
    houseNumber: int

    def __init__(self, id: str, width: int, height: int):
        self.ID = id
        self.constraints = []
        self.entities = set()
        self.size = (width, height)

class Solution:
    problem: ParsedProblem
    # List Index = House Number
    var: List[Person] = []

# --- THE PARSER (Your Part) ---


class Solver:
    """
    Complete symbolic CSP solver for ZebraLogicBench-style puzzles.
    """

    def __init__(self):
        self.steps = 0

    def solve(self, problem: ParsedProblem) -> Solution:
        self.steps = 0

        width, height = problem.size
        n = width  # number of houses

        solution = Solution()
        solution.var = [{"properties": {}} for _ in range(n)]

        entities = list(problem.entities)
        domains = {entity: set(range(n)) for entity in entities}

        success = self._backtrack(
            solution,
            entities,
            domains,
            problem.constraints,
            assigned_entities=set()
        )

        return solution if success else Solution()

    def _backtrack(self, solution, entities, domains, constraints, assigned_entities):
        if len(assigned_entities) == len(entities):
            return self._check_constraints(solution, constraints)

        self.steps += 1
        entity = next(e for e in entities if e not in assigned_entities)

        for house_idx in domains[entity]:
            if entity in solution.var[house_idx]["properties"].values():
                continue

            solution.var[house_idx]["properties"][entity] = entity
            assigned_entities.add(entity)

            if self._check_constraints(solution, constraints):
                if self._backtrack(solution, entities, domains, constraints, assigned_entities):
                    return True

            del solution.var[house_idx]["properties"][entity]
            assigned_entities.remove(entity)

        return False

    def _check_constraints(self, solution, constraints):
        for constraint in constraints:
            if not constraint.isSatisfied(solution):
                return False

        seen = set()
        for house in solution.var:
            for value in house["properties"].values():
                if value in seen:
                    return False
                seen.add(value)

        return True


# --- verification (Not part of the class file, but for testing) ---
if __name__ == "__main__":
    # Simulating data from the ZebraLogicBench 'puzzle' column
    sample_puzzle_text = "There are 5 houses. The Englishman lives in the red house. The Spaniard owns the dog."
    
    raw = RawProblem("lgp-test-5x6-16", sample_puzzle_text)
    parser = Parser()
    result = parser.parse(raw)
    
    print(f"Parsed ID: {result.ID}")
    print(f"Entities: {result.entities}")
    print(f"Constraints: {result.constraints}")
